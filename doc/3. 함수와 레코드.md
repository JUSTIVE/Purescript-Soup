# í•¨ìˆ˜ì™€ ë ˆì½”ë“œ

## ì£¼ì„

```purescript
-- í•œì¤„ì»¤ë©˜íŠ¸

{-
  ë©€í‹°ë¼ì¸ ì»¤ë©˜íŠ¸
-}
```

## ê¸°ë³¸ íƒ€ì…

Prim ëª¨ë“ˆì— ì •ì˜ëœ, ìë°”ìŠ¤í¬ë¦½íŠ¸ì— ëŒ€ì‘ë˜ëŠ” íƒ€ì…ë“¤

```purescript
$ spago repl

> :type 1.0
Number

> :type "test"
String

> :type true
Boolean
```

`:type` ì„ ì´ìš©í•˜ì—¬ ê¸°ë³¸ íƒ€ì…ì˜ì„ ì¶œë ¥í•  ìˆ˜ ìˆìŒ

### purescriptì˜ ë‚´ì¥ íƒ€ì…ë“¤

- Int
- Char
- Array
  - Javascriptì˜ ê²ƒê³¼ ë¹„ìŠ·í•˜ì§€ë§Œ, ëª¨ë“  ìš”ì†Œê°€ ê°™ì€ íƒ€ì…ì´ì–´ì•¼ í•©ë‹ˆë‹¤.

```purescript
> :type [1, 2, 3]
Array Int

> :type [true, false]
Array Boolean

> :type [1, false]
Error found:
in module $PSCI
at :1:1 - 1:10 (line 1, column 1 - line 1, column 10)

  Could not match type

    Int

  with type

    Boolean


while inferring the type of [ 1
                            , false
                            ]
in value declaration it

See https://github.com/purescript/documentation/blob/master/errors/TypesDoNotUnify.md for more information,
or to contribute content related to this error.
```

ë ˆì½”ë“œëŠ” ìë°”ìŠ¤í¬ë¦½íŠ¸ì˜ ê°ì²´ì— ëŒ€ì‘ë˜ê³ , ìë°”ìŠ¤í¬ë¦½íŠ¸ì˜ ë¦¬í„°ëŸ´ ê°ì²´ì™€ ê°™ì€ ì‹ íƒìŠ¤ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.

```purescript
> author = { name: "Phil", interests: ["Functional Programming", "JavaScript"] }

> :type author
{ name :: String
, interests :: Array String
}
```

í•„ë“œëŠ” `.` ì„ ì´ìš©í•´ì„œ ì ‘ê·¼ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.

purescriptì˜ í•¨ìˆ˜ëŠ” javascriptì˜ í•¨ìˆ˜ì— ëŒ€ì‘ë©ë‹ˆë‹¤.

```purescript
> import Prelude
> :type flip
  forall a b c. (a -> b -> c) -> b -> a -> c

> :type const
forall a b. a -> b -> a
-- k combinator(kestrel combinator)
-- https://www.angelfire.com/tx4/cus/combinator/birds.html
```

í•¨ìˆ˜ ë°”ë¡œ ìœ„ì— íƒ€ì…ì„ ì ì„ ìˆ˜ ìˆë‹¤.
í•¨ìˆ˜ëŠ” ì¸ì ì•ì— `=` ë¥¼ ì¨ì„œ íŒŒì¼ ìµœìƒìœ„ì— ì‘ì„±ë  ìˆ˜ ìˆë‹¤.

```purescript
add :: Int -> Int -> Int
add x y = x + y
```

í˜¹ì€, ì¸ì ëª©ë¡ ì•ì— `\` ë¥¼ ì´ìš©í•˜ì—¬ ì¸ë¼ì¸ìœ¼ë¡œ ì •ì˜í•  ìˆ˜ ìˆë‹¤.
PSCiì—ì„œëŠ” :paste ì»¤ë§¨ë“œë¥¼ í†µí•´ paste ëª¨ë“œë¥¼ ì´ìš©í•´ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤. (ì¢…ë£ŒëŠ” control+D ì´ë‹¤)

## ì •ëŸ‰í™”ëœ íƒ€ì…

```purescript
> import Prelude
> :type flip
  forall a b c. (a -> b -> c) -> b -> a -> c

> :type const
forall a b. a -> b -> a
-- k combinator(kestrel combinator)
```

ìœ„ì˜ ì´ ì½”ë“œì—ì„œ `forall(âˆ€)`í‚¤ì›Œë“œëŠ” `flip`ì´ ë³´í¸ì ìœ¼ë¡œ ì •ëŸ‰í™”ëœ íƒ€ì…ì„ ê°€ì§„ë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•©ë‹ˆë‹¤.
ì´ëŠ” a,b,cì— ëŒ€í•´ì„œ ëª¨ë“  íƒ€ì…ìœ¼ë¡œ ëŒ€ì²´í•  ìˆ˜ ìˆê³ , flipì´ ì´ì— ë™ì‘í•  ê²ƒì´ë¼ëŠ” ê²ƒì…ë‹ˆë‹¤.

> <'a,'b,'c> ê°™ì€ê±°

ì´ëŸ° universally quantified typeë“¤ì€ ê²°ì •ë˜ì–´ì§ˆ ìˆ˜ ìˆë‹¤.

```
(Int -> String -> String) -> String -> Int -> String
```

ì´ëŸ¬í•œ íŠ¹ìˆ˜í™”ëŠ” ì•”ë¬µì ìœ¼ë¡œ ìˆ˜í–‰ëœë‹¤.

```purescript
-- <> ëŠ” string concat
{-
> import Prelude
> "ab" <> "c"
"abc"
> "ab" <> 10
Error found:
in module $PSCI
at :1:9 - 1:11 (line 1, column 9 - line 1, column 11)

  Could not match type

    Int

  with type

    String


while checking that type Int
  is at least as general as type String
while checking that expression 10
  has type String
in value declaration it

-}

-- show ëŠ” ì•„ë˜ì™€ ê°™ìŒ
{-
> :type show
forall (a :: Type). Show a => a -> String
-}
> flip (\n s -> show n <> s) "Ten" 10

"10Ten"
```

## ì¸ë´íŠ¸

í“¨ì–´ìŠ¤í¬ë¦½íŠ¸ëŠ” íŒŒì´ì¬,fsharp,haskellê³¼ ê°™ì´ ì¸ë´íŠ¸ ê¸°ë°˜ìœ¼ë¡œ ë¸”ë¡ì„ êµ¬ë¶„í•œë‹¤.
where, of let ê³¼ ê°™ì€ í‚¤ì›Œë“œëŠ” ìƒˆ ì½”ë“œ ë¸”ëŸ­ì„ ì œì‹œí•œë‹¤.

## ìš°ë¦¬ íƒ€ì… ì •ì˜í•˜ê¸°

ì£¼ì†Œë¡ íƒ€ì…ì€ ë‹¤ìŒê³¼ ê°™ì´ ì •ì˜í•  ìˆ˜ ìˆë‹¤.

```purescript
type Address =
  { street  :: String
  , city    :: String
  , state   :: String
  }

type Entry =
  { firstName :: String
  , lastName  :: String
  , address   :: Address
  }

type AddressBook = List Entry
```

ë ˆì½”ë“œë¡œ êµ¬ì„±ëœ ê°ê°ì˜ ì£¼ì†Œ, ì—”íŠ¸ë¦¬ ( ì—¬ê¸°ì„œ ë ˆì½”ë“œì˜ ì¤‘ì²©ì„ ë³¼ ìˆ˜ ìˆë‹¤).
ì£¼ì†Œë¡ì€ ë‹¨ìˆœíˆ ì—”íŠ¸ë¦¬ì˜ ë¦¬ìŠ¤íŠ¸ë¡œ í‘œí˜„í•  ìˆ˜ ìˆë‹¤.

## íƒ€ì… ìƒì„±ìì™€ ì¢…ë¥˜

ìœ„ì˜ `List`ëŠ” íƒ€ì… ìƒì„±ìì´ë‹¤.

`Nil`ê³¼ ê°™ì€ ê°’ì„ ìƒì„±ìì— ë„£ìœ¼ë ¤ í•˜ë©´ _kind error_ ê°€ ë°œìƒí•œë‹¤

```purescript
> import Data.List
> Nil :: List
Error found:
in module $PSCI
at <internal>:0:0 - 0:0 (line 0, column 0 - line 0, column 0)

  In a type-annotated expression x :: t, the type t must have kind Type.
  The error arises from the type

    List

  having the kind

    Type -> Type

  instead.

in value declaration it

See https://github.com/purescript/documentation/blob/master/errors/ExpectedType.md for more information,
or to contribute content related to this error.
```

ì´ê²Œ ì–´ë–¤ íƒ€ì…ì¸ì§€ ì•Œê³  ì‹¶ìœ¼ë©´ `:kind`ë¥¼ ì“°ë¼
(ê°’ì˜ íƒ€ì…ì„ ì•Œê³ ì‹¶ìœ¼ë©´ `:type`, íƒ€ì… aliasì˜ ê°’ì„ ì•Œê³  ì‹¶ìœ¼ë©´ `:kind`)

## ì£¼ì†Œë¡ ì—”íŠ¸ë¦¬ ì¶œë ¥í•˜ê¸°

ì£¼ì†Œë¡ ì—”íŠ¸ë¦¬ë¥¼ ì¶œë ¥í•˜ëŠ” í•¨ìˆ˜ë¥¼ ë§Œë“¤ì–´ë³´ì.

```purescript
showEntry :: Entry -> String
-- íƒ€ì… ì‹œê·¸ë‹ˆì³
showEntry entry = entry.lastName <> ", " <>
                  entry.firstName <> ": " <>
                  showAddress entry.address

showAddress :: Address -> String
showAddress address = address.street <> ", " <>
                      address.city <> ", " <>
                      address.state
```

## ì£¼ì†Œë¡ ë§Œë“¤ê¸°

Data.Listì˜ Cons í•¨ìˆ˜ë¥¼ ë³´ì

```purescript
> import Data.List
> :type Cons
forall a. a -> List a -> List a
-- ì´ëŠ” ë¦¬ìŠ¤íŠ¸ì— ê°’ì„ ì¶”ê°€í•˜ëŠ” ê²ƒ.
-- ëª¨ë“  ë°ì´í„°ê°€ ë¶ˆë³€ì´ë‹ˆê¹Œ ì´ë ‡ê²Œ ë‹¤ë£¬ë‹¤
```

## ì»¤ë§

TLDR; ì˜¤í† ì»¤ë§ ë˜ê³  point-free styleì…ë‹ˆë‹¤ (ì˜¬ë ˆ~)

```purescript
insertEntry:: Entry -> AddressBook -> AddressBook
insertEntry = Cons

{-
ìœ„ì™€ ê°™ì´ í•¨ìˆ˜ì˜ ë§ˆì§€ë§‰ ì¸ìë¥¼ ì‘ì„±í•˜ì§€ ì•ŠëŠ” ê²ƒì€ point-free ìŠ¤íƒ€ì¼ì´ë¼ í•¨
a.k.a. eta conversion
-}
```


## ì†ì„± ì ‘ê·¼ì

purescript ì—ì„œëŠ” `_.ì†ì„±ì´ë¦„` ì˜ í˜•íƒœë¡œ ë ˆì½”ë“œë¥¼ ì•¡ì„¸ìŠ¤ í•  ìˆ˜ ìˆëŠ” ëŒë‹¤ë¥¼ ì œê³µ

```purescript
> address = { street: "123 Fake St.", city: "Faketown", state: "CA" }
> entry = { firstName: "John", lastName: "Smith", address: address }
> _.lastName entry
"Smith"

-- is equivalent of
\entry -> entry.lastName

> _.address.city entry
"Faketown"

-- is equivalent of
\entry -> entry.address.city
```

## ì£¼ì†Œë¡ ì¿¼ë¦¬í•˜ê¸°

```purescript
> :type filter
forall a. (a -> Boolean) -> List a -> List a
-- a íƒ€ì…ì— ëŒ€í•´ì„œ predicator, targetList -> resultList

> :type head
forall a. List a -> Maybe a
-- a íƒ€ì…ì— ëŒ€í•´ì„œ List<a> ì˜ ì²« ìš”ì†Œ option<a> íƒ€ì… ë°˜í™˜

findEntry :: String -> String -> AddressBook -> Maybe Entry
findEntry firstName lastName book = head (filter filterEntry book)
  where
    filterEntry :: Entry ->Boolean
    filterEntry  entry = entry.firstName == firstName && entry.lastName == lastName
-- predicator ì¸ filterEntryë¥¼ local functionìœ¼ë¡œ ì •ì˜í•œ ëª¨ìŠµ. (where í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•´ì„œ)
```

## ì¤‘ìœ„ í•¨ìˆ˜ ì ìš©

ëŒ€ë¶€ë¶„ì˜ í•¨ìˆ˜ë“¤ì€ ì „ìœ„í‘œê¸°ì§€ë§Œ(op lvalue rvalue ìˆœ), `==` ì™€ ê°™ì€ ê²ƒë“¤ì€ ì¤‘ìœ„(lvalue op rvalue) ì´ì§„ ì—°ì‚°ìì´ë‹¤.
`==` ëŠ” `eq` í•¨ìˆ˜ì˜ ì¤‘ìœ„í‘œê¸° ë²„ì „ì¸ë°, ë‹¤ìŒê³¼ ê°™ì´ ì •ì˜ëœ ê²ƒì´ë‹¤.

```purescript
infix 4 eq as ==
-- ì—¬ê¸° ì§ˆë¬¸!!!!! 4ëŠ” ë¬´ì—‡ì´ê³  ì™œ ë“±ì¥í•˜ëŠ”ê°€.. (ì°¾ì•˜ë‹¤: ì—°ì‚°ì ìš°ì„ ìˆœìœ„)

-- ë”°ë¼ì„œ entry.firstName == firstNameì€ ì•„ë˜ì™€ë„ ê°™ë‹¤
eq entry.firstName firstName

-- í˜¹ì€ ì´ê²ƒê³¼ë„ ê°™ë‹¤
eq (_.firstName entry) firstName

-- í˜¹ì€ ì´ê²ƒê³¼ë„ ê°™ë‹¤(ëª¨ë“  ì‹ íƒìŠ¤ ìŠˆê±° ì œê±°)
eq (\entry -> entry.firstName)
```

`mod` ì—°ì‚°ìë„ ì¤‘ìœ„í‘œê¸°ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

```purescript
> mod 8 3
-- is equivalent of
> 8 `mod` 3
-- ì´ì²˜ëŸ¼ ë°±í‹±ì„ ì‚¬ìš©í•˜ë©´ ì¼ë°˜ í•¨ìˆ˜ë„ ì¤‘ìœ„í‘œê¸°ë¡œ ë³€ê²½í•  ìˆ˜ ìˆë‹¤.
```

ì¤‘ìœ„ ì—°ì‚°ìëŠ” ìš°ì¸¡/ í˜¹ì€ ì¢Œì¸¡ ê²°í•©ì„±ì„ ê²°ì •í•  ìˆ˜ ìˆë‹¤.
|í‚¤ì›Œë“œ| ì´ë¦„ | ì˜ˆì‹œ |
|---|---|---|
| infixl | ì¢Œì¸¡ ê²°í•© | (a op b op c) eq (a op b) op c))
| infixr | ìš°ì¸¡ ê²°í•© | (a op b op c) eq (a op (b op c))
| infix | ë¬´ê²°í•© | (a op b op c) -> NonAssociativeError, ê´„í˜¸ë¡œ ì§€ì‹œí•´ì•¼ í•¨

```purescript
-- john, peggy, nedë¥¼ emptyBookì— ë„£ëŠ”ë‹¤ê³  í–ˆì„ ë•Œ, prefix function ì‚¬ìš©
book3 = insertEntry john (insertEntry peggy (insertEntry ned emptyBook))

-- infix function ì‚¬ìš© í•  ë•Œ
book4 = john `insertEntry` (peggy `insertEntry` (ned `insertEntry` emptyBook))

-- infixr ++ opë¡œ ì¹˜í™˜í–ˆì„ ë•Œ
infixr 5 insertEntry as ++
book6 = john ++ peggy ++ ned ++ emptyBook

-- infixl ++ opë¡œ ì¹˜í™˜í–ˆì„ ë•Œ
infixr 6 insertEntry as ++
book7 = emptyBook ++ john ++ peggy ++ ned

-- apply í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ì„œ í‘œì‹œí•œ ê²ƒ
book3 = insertEntry john $ insertEntry peggy $ insertEntry ned emptyBook
{-
ìœ„ì˜ `$` ëŠ” apply í•¨ìˆ˜ì˜ alias.
apply í•¨ìˆ˜ëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.
-}

apply :: forall a b. (a->b) -> a -> b
apply f x = f x
infixr 0 apply as $

{-
ì—¬ê¸°ì„œì˜ applyëŠ” ì‚¬ì‹¤ ì¼ë°˜ì ì¸ í•¨ìˆ˜ì˜ ì ìš©ì„ ë‚˜íƒ€ë‚¸ ê²ƒìœ¼ë¡œ ì•„ë¬´ëŸ° ê¸°ëŠ¥ì„ í•˜ì§€ ì•Šì§€ë§Œ
(ì´ëŠ” ì°¸ì¡° íˆ¬ëª…ì„±ì— ì˜í•¨)
í•¨ìˆ˜ ì ìš©ì„ ì¤‘ìœ„ ì—°ì‚°ìë¡œ êµ¬ì¡°ì ì¸ ë³€ê²½ì„ ê°€ëŠ¥í•˜ê²Œ í•˜ëŠ” ìœ í‹¸ë¦¬í‹°ì„± í•¨ìˆ˜ì´ë‹¤.
-}


--ì´ë¥¼ ê°ì•ˆí–ˆì„ ë•Œ, findEntry ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì‘ì„±í•  ìˆ˜ë„ ìˆë‹¤.
findEntry :: String -> String -> AddressBook -> Maybe Entry
findEntry firstName lastName book = head $ filter filterEntry book
  where
    filterEntry :: Entry ->Boolean
    filterEntry  entry = entry.firstName == firstName && entry.lastName == lastName
```

## í•¨ìˆ˜ í•©ì„±

í•¨ìˆ˜ë“¤ë§Œì„ í•©ì„±í•˜ê³  ì‹¶ì„ë•Œ. 
í•¨ìˆ˜ë§Œ íŒŒì´í”„ë¡œ ë¶™ì—¬ë²„ë¦¬ê³  ì‹¶ì„ë•Œ!

```
ğŸ -> ğŸŒ ì¸ í•¨ìˆ˜ Aì™€
ğŸŒ -> ğŸ… ì¸ í•¨ìˆ˜ Bê°€ ìˆì„ ë•Œ

A ì™€ Bë¥¼ í•©ì³ì„œ
ğŸ -> ğŸ… ì¸ í•¨ìˆ˜ Cë¥¼ ë§Œë“¤ ìˆ˜ ìˆë‹¤
ã„´ ì—¬ê¸°ì„œ ì•„ë¬´ë„ ë°”ë‚˜ë‚˜ì˜ ì¡´ì¬ë¥¼ ì•Œ ìˆ˜ë„ ì—†ê³ , ê´€ì‹¬ê°€ì§ˆ í•„ìš”ë„ ì—†ë‹¤

í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì—ì„œì˜ ìº¡ìŠí™”
```

| ì—°ì‚°ì | ì´ë¦„ | íš¨ê³¼ |
| --- | ---| ---|
| <<< | í›„ë°© í•©ì„± | ('b -> 'c) -> ('a -> 'b) -> ('a -> 'c) |
| >>> | ì „ë°© í•©ì„± | ('a -> 'b) -> ('b -> 'c) -> ('a -> 'c) |

