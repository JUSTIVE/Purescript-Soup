# 패턴 매칭

이 장에서는 두 개념을 소개합니다

- 대수적 데이터 타입
- 패턴 매칭

패턴매칭은 함수형 프로그래밍에서 간결하고 복잡한 개념들을 여러 분기로 쪼개서 구현해서 표현할 수 있는 방법

Data.Picture는

- 간단한 모형들을 위한 데이터 타입 `Shape`와
- 도형의 집합과 이 타입을 다룰 수 있는 함수들이 있는 `Picture`타입
  을 정의합니다

```purescript
module Data.Picture where

import Prelude
import Data.Foldable (foldl)
import Data.Number (infinity)
```

`Data.Picture` 모듈은 `Number` 모듈을 포함하는데, 여기서 `as` 키워드를 사용합니다

```purescript
import Data.Number as Number
```

해당 모듈에 있는 함수나 타입들을 Number.max 와 같이 제한된 이름으로 가져올 뿐만 아니라, import의 중첩을 피하고 모듈에서 가져오는 것들을 명확하게 하는 것에 있습니다.

## 간단한 패턴 매칭

_아는 맛_

유클리드 호제법을 다룬 예제

```purescript
gcd :: Int -> Int -> Int
gcd n 0 = n
gcd 0 m = m
gcd n m = if n > m
            then gcd (n - m) m
            else gcd n (m - n)
```

rescript equivalent

```rescript
let rec gcd = (n,m) => {
  switch (n,m) {
  | (n,0) => n
  | (0,m) => m
  | (n,m) =>{
      if (n > m){
        gcd(n-m,m)
      }
      else{
        gcd(n,m-n)
      }
    }
}
```

## 단순한 패턴

```purescript
fromString :: String -> Boolean
fromString "true" = true
fromString _      = false

toString :: Boolean -> String
toString true = "true"
toString false = "false"
```

## 가드

_아는 맛2_

위의 유클리드 호제법에서 `if .. then .. else` 의 표현은 `m>n` 과 `m<=n` 으로 나눌 수 있다. 이 경우에는 가드를 사용할 수 있다.

```purescript
gcdV2 :: Int -> Int -> Int
gcdV2 n 0 = n
gcdV2 0 m = m
gcdV2 n m | n > m     = gcdV2 (n-m) m
          | otherwise = gcdV2 n (m-n)
```

rescript equivalent

```rescript
let rec gcdv2 = (n,m) => {
  switch (n,m) {
  | (n,0) => n
  | (0,m) => m
  | (n,m) if (n > m) =>gcd(n-m,m)
  | (n,m) => gcd(n,m-n)
}
```

## 배열 패턴

```purescript
isEmpty :: forall a. Array a -> Boolean
isEmpty [] = true
isEmpty _ = false
```

```purescript
takeFive :: Array Int -> Int
takeFive [0,1,a,b,_] = a * b
takeFive _ = 0
```

배열 패턴매칭은 고정된 길이에만 적용할 수 있으므로, 정해지지 않은 길이를 대응하기 위해서는 Data.List를 사용할 것(h::l)

## 레코드 패턴과 열 다형성

레코드 패턴은 레코드에 패턴 매칭할 때 사용

```purescript
showPerson :: {first::String,last::String}->String
showPerson {first:x,last:y} = y <> ", " <> x
```

ts나 js의 object destructuring 같은 느낌

레코드 패턴은 purescript의 열 다형성을 보여주기 매우 적절한 예시

```purescript
> showPerson {first:x,last:y} = y <> ", " <> x

> :type showPerson
forall r. {first::String, last::String | r} -> String
{- 여기서의 r 은 무엇일까요? 두둥탁-}
```

이 선언은 저 위에서 선언한 것처럼 함수타입을 선언했을 때와는 다른 타입을 가진다.

```purescript
> showPerson { first: "Phil", last: "Freeman" }
"Freeman, Phil"

> showPerson { first: "Phil", last: "Freeman", location: "Los Angeles" }
"Freeman, Phil"
```

showPerson의 인자에 추가 필드를 넣었을 때도 정상적으로 동작한다. 그러나 적은 필드일 경우에는 에러가 발생한다.

```purescript
> showPerson { first: "Phil" }

Type of expression lacks required label "last"
```

즉, 아까 위에서의 r은 다른 아무 필드를 의미하는 것이다. 이 함수는 레코드 필드 r에 대해서 다형성을 띈다(열 다형성).
열 변수 r이 없다면 showPerson은 오로지 제한된 필드를 가진 레코드만을 인자로 받는다.

## 레코드 말장난

함수 타입 선언에서 사용한 레코드 필드 이름을 그대로 함수 선언에 사용할 수 있다.

```purescript
showPersonV2 :: { first :: String, last :: String } -> String
showPersonV2 { first, last } = last <> ", " <> first
```

```purescript
unknownPerson :: { first :: String, last :: String }
unknownPerson = { first, last }
  where
    first = "Jane"
    last  = "Doe"

```

그 이름을 타입을 레코드 구성할 때에도 사용할 수 있다.
