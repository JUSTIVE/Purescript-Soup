# ì ìš©ê°€ëŠ¥í•œ ê²€ì¦(Applicative Validation)

## ì´ ì¥ì˜ ëª©í‘œ

- ìƒˆë¡œìš´ ì¶”ìƒì˜ ì†Œê°œ
  - _applicative functor_ : `Applicative` í´ë˜ìŠ¤ì— ì˜í•´ ì„¤ëª…ë¨.
  - `Traversable` íƒ€ì… í´ë˜ìŠ¤ : _traversable functor_ ë¥¼ ì„¤ëª…í•¨.

## í•¨ìˆ˜ ì ìš©ì„ ì¼ë°˜í™”í•˜ê¸°

applicative functorë¥¼ ì•ì—ì„œ ë³¸ Maybeë¡œ ì´í•´í•˜ê¸°

```purescript
address :: String -> String -> String -> Address
```
ì´ í•¨ìˆ˜ë¥¼ Maybeì™€ ê°™ì´ ì‚¬ìš©í•˜ê¸° (ëª¨ë“  ì¸ìê°€ Maybeë¡œ ë˜í•‘ëœë‹¤ë©´?)

lift í•¨ìˆ˜ëŠ” ì´ í•¨ìˆ˜ì˜ ì¸ìë¥¼ Maybeë¡œ ê°ì‹¸, Justê°€ ì—†ëŠ” ê²½ìš° Nothingìœ¼ë¡œ ì²˜ë¦¬(flatMap)

```
lift3 address :: Maybe String -> Maybe String -> Maybe String -> Maybe Address
```

## ì„ì˜ì˜ í•¨ìˆ˜ë¥¼ ëŒì–´ì˜¬ë¦¬ê¸°(lifting)

lift2, lift3 ë“± ê³ ì •ëœ ì¸ìê°€ ì•„ë‹Œ, n-arity ì˜ í•¨ìˆ˜ë¥¼ lifting í•˜ê³  ì‹¶ë‹¤!

lift3 ëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤

```purescript
:type3 lift3
forall a b c d f. Apply f => (a->b->c->d) -> f a -> f b -> f c -> f d
```

[typescriptì—ì„œ ì´ëŸ° HKTë¥¼ ì“°ë ¤ë©´.. (ğŸ¤”)](https://www.matechs.com/blog/encoding-hkts-in-typescript-once-again#:~:text=Multi%20Parameter%20Encoding)

ëª¨ë“  íƒ€ì…ì— ëŒ€í•´ì„œ ìœ„ì™€ ê°™ì´ Applyë¥¼ í•  ìˆ˜ëŠ” ì—†ì„ ê²ƒ. ì•ì—ì„œëŠ” Apply íƒ€ì…ì¸ Maybeë¥¼ ì‚¬ìš©í–ˆë‹¤.
preludeì— ì •ì˜ëœ Apply íƒ€ì… í´ë˜ìŠ¤ëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤

```purescript 
class Functor f where
  map :: forall a b. (a -> b) -> f a -> f b

class Functor f <= Apply f where
  apply :: forall a b. f (a -> b) -> f a -> f b
```
(ìœ„ì˜ ë‘˜ì„ ê°€ì§€ë©´ Apply íƒ€ì…)

Apply íƒ€ì… í´ë˜ìŠ¤ëŠ” Functor íƒ€ì… í´ë˜ìŠ¤ì˜ í•˜ìœ„ íƒ€ì… í´ë˜ìŠ¤ì´ê³ , ì¶”ê°€ì ì¸ `apply` í•¨ìˆ˜ë¥¼ ê°€ì§„ë‹¤.

`<$>` -> ë§µ
`<*>` -> ì–´í”Œë¼ì´

ì´ ë‘˜ì˜ ì°¨ì´ëŠ” mapì€ ì¸ìë¡œ í•¨ìˆ˜ë¥¼ ë°›ê³ , applyëŠ” íƒ€ì… ìƒì„±ì f ë¡œ ê°ì‹¸ì§„ íƒ€ì…ì„ ë°›ëŠ”ë‹¤. 

ì¼ë°˜í™”í•˜ë©´ ì„ì˜ì˜ ì¸ìì— ëŒ€í•´ì„œ ì²« ì¸ìì—ëŠ” `<$>`ë¥¼, ì´í›„ì—ëŠ” `<*>` ë¥¼ ì ìš©í•˜ë©´ ëœë‹¤.

_lift3ì˜ ì˜ˆì‹œ_

```purescript
lift3 :: forall a b c d f
       . Apply f
      => (a -> b -> c -> d)
      -> f a
      -> f b
      -> f c
      -> f d
lift3 f x y z = f <$> x <*> y <*> z
```

`ado:applicative do notation` í‘œê¸°ë¡œ ë‚˜íƒ€ë‚´ì—ˆì„ ë•Œ

```purescript
lift3 f x y z = ado
  a <- x
  b <- y
  c <- z
  in f a b c
```

## 'ì ìš©ê°€ëŠ¥í•œ' íƒ€ì… í´ë˜ìŠ¤

ìœ„ì™€ ê´€ë ¨ëœ `Applicative` íƒ€ì… í´ë˜ìŠ¤ê°€ ìˆë‹¤.

```purescript
class Apply f <= Applicative f where
   pure :: forall a. a-> f a
```

Applyì˜ í•˜ìœ„ íƒ€ì…ìœ¼ë¡œ, pure í•¨ìˆ˜ë¥¼ ê°€ì§.

```purescript
instance applicativeMaybe :: Applicative Maybe where
  pure x = Just x
```

## 'ì ìš©ê°€ëŠ¥í•œ'ì— ëŒ€í•œ ì§ê´€

í“¨.ìŠ¤. ì˜ í•¨ìˆ˜ë“¤ì€ ìˆœìˆ˜í•˜ê³ , ë¶€ìˆ˜ì‘ìš©ì„ ë‹¤ë£¨ì§€ ì•ŠìŒ.
ì ìš©ê°€ëŠ¥í•œ í•¨ìë“¤ì€ í•¨ì fì— ì¸ì½”ë”©ë˜ì–´ ë¶€ìˆ˜ì‘ìš©ì„ ë‹¤ë£¨ëŠ” í•¨ìˆ˜ë¥¼ êµ¬í˜„í•œë‹¤!

[ì œê°€ ìƒê°ë‚¬ë˜ ê²ƒ: 4ì°¨ì› ì„¸ê³„ë¥¼ ì‚¬ìƒí•  ìˆ˜ ìˆëŠ” ê²Œì„-ë¯¸ì—ê°€ì¿ ë ˆ](https://www.youtube.com/watch?v=9yW--eQaA2I&ab_channel=%5Bmtbdesignworks%7BMiegakure%2C4DToys%7D%5D)

ì˜ˆë¥¼ ë“¤ì–´,

- ì—†ì„ ìˆ˜ë„ ìˆëŠ” ê°’ì„ ë‹¤ë£¨ëŠ” `Maybe`
- ì‹¤íŒ¨ë¥¼ ë‹¤ë£¨ëŠ” `Either/Result`
- ì „ì—­ ê°’ì„ ì½ì–´ì˜¤ëŠ” `Arrow functor(r->)`

ì¦‰, pureí•œ ê²ƒë“¤ë§Œ ìƒê°í•˜ê³ , ë‚˜ë¨¸ì§€ëŠ” ëª¨ë‘ Applicativeì˜ ì„¸ê³„ì—ì„œ ì²˜ë¦¬í•  ê²ƒ.

## ë” ë§ì€ íš¨ê³¼ë“¤

lift3 (string->string->string) Maybe ì— ëŒ€í•´ì„œ íŒ¨í„´ë§¤ì¹­ì„ í†µí•œ Eitherë¡œì˜ ì‚¬ìƒì´ ê°€ëŠ¥

```purescript
> import Data.Either
> :paste
â€¦ withError Nothing  err = Left err
â€¦ withError (Just a) _   = Right a
â€¦ ^D

> :paste
â€¦ fullNameEither first middle last =
â€¦   fullName <$> (first  `withError` "First name was missing")
â€¦            <*> (middle `withError` "Middle name was missing")
â€¦            <*> (last   `withError` "Last name was missing")
â€¦ ^D

> fullNameEither (Just "Phillip") (Just "A") (Just "Freeman")
(Right "Freeman, Phillip A")

> fullNameEither (Just "Phillip") Nothing (Just "Freeman")
(Left "Middle name was missing")

> fullNameEither (Just "Phillip") (Just "A") Nothing
(Left "Last name was missing")
```

ê·¸ëŸ¬ë‚˜ ì²˜ìŒ ë°œìƒí•œ ì—ëŸ¬ë§Œ ì¡ì„ ìˆ˜ ìˆìŒ.
(ì»´íŒŒì¼ëŸ¬ê°€ ì´ë ‡ê²Œ ì—ëŸ¬ë¥¼ ì¡ì•„ì¤¬ë‹¤ë©´ ë§¤ìš° í™”ë‚¬ì„ ê²ƒ)

íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ë¡œ ì´ëŸ° ìƒê°ì„ êµ¬í˜„í–ˆë˜ íƒ€ì… ì°¨ë ¥ì‡¼..
```typescript
import {
  Fail,
  Result,
  Success
} from '../Result/Result';
import {
  isFail,
  isSuccess
} from '../Result/ResultTypeGuardFunc';
import {
  AllFail,
  AllSuccess,
  PartialSuccess,
  Summary
} from './Summary';

export function genSummary<TValue, TReason, TEvidence>
(resultList: Result<TValue, TReason, TEvidence>[])
  : Summary<TValue, TReason, TEvidence> {
  if (resultList.every(isSuccess)) return genAllSuccess(resultList);
  else if (resultList.every(isFail)) return genAllFail(resultList);
  else return genPartialSuccess(resultList);
}

export function genAllSuccess<TValue>
(successList: Success<TValue>[])
  : AllSuccess<TValue> {
  return {
    summaryType: 'AllSuccess',
    value: successList
  };
}

export function genAllFail<TReason, TEvidence>
(failList: Fail<TReason, TEvidence>[])
  : AllFail<TReason, TEvidence> {
  return {
    summaryType: 'AllFail',
    value: failList
  };
}

export function genPartialSuccess<TValue, TReason, TEvidence>
(resultList: Result<TValue, TReason, TEvidence>[])
  : PartialSuccess<TValue, TReason, TEvidence> {
  return {
    summaryType: 'PartialSuccess',
    successes: resultList.filter(isSuccess),
    fails: resultList.filter(isFail)
  };
}
```


## íš¨ê³¼ ê²°í•©í•˜ê¸°

A (B x) ë¥¼ B (A x)ë¡œ ë°”ê¾¸ê¸°

[ë¶€íŠ¸ìº í”„ë•Œ ë§Œë“  Array<Option<T>> ë¥¼ Option<Array<T>>ë¡œ ë°”ê¾¸ëŠ” ì½”ë“œ](https://github.com/JUSTIVE/Rescriptive/blob/main/src/Rscv_Array.res#:~:text=let%20everyO%20%3D,%7D)

```purescript
combineList :: forall f a. Applicative f => List (f a) -> f (List a)
```

## ì ìš© ê°€ëŠ¥í•œ ê²€ì¦

ìœ„ì˜ Eitherë¥¼ ì´ìš©í•œ ì²« ì—ëŸ¬ë§Œ ì¡ëŠ” ìƒí™©ì„ í•´ê²°í•  ë°©ë²• `V`

